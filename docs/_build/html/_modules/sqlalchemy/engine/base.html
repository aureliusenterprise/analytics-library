
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>sqlalchemy.engine.base &#8212; analytics-library  documentation</title>
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for sqlalchemy.engine.base</h1><div class="highlight"><pre>
<span></span><span class="c1"># engine/base.py</span>
<span class="c1"># Copyright (C) 2005-2018 the SQLAlchemy authors and contributors</span>
<span class="c1"># &lt;see AUTHORS file&gt;</span>
<span class="c1">#</span>
<span class="c1"># This module is part of SQLAlchemy and is released under</span>
<span class="c1"># the MIT License: http://www.opensource.org/licenses/mit-license.php</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">with_statement</span>

<span class="sd">&quot;&quot;&quot;Defines :class:`.Connection` and :class:`.Engine`.</span>

<span class="sd">&quot;&quot;&quot;</span>


<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">exc</span><span class="p">,</span> <span class="n">util</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">interfaces</span>
<span class="kn">from</span> <span class="nn">..sql</span> <span class="k">import</span> <span class="n">util</span> <span class="k">as</span> <span class="n">sql_util</span>
<span class="kn">from</span> <span class="nn">..sql</span> <span class="k">import</span> <span class="n">schema</span>
<span class="kn">from</span> <span class="nn">.interfaces</span> <span class="k">import</span> <span class="n">Connectable</span><span class="p">,</span> <span class="n">ExceptionContext</span>
<span class="kn">from</span> <span class="nn">.util</span> <span class="k">import</span> <span class="n">_distill_params</span>
<span class="kn">import</span> <span class="nn">contextlib</span>


<span class="k">class</span> <span class="nc">Connection</span><span class="p">(</span><span class="n">Connectable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Provides high-level functionality for a wrapped DB-API connection.</span>

<span class="sd">    Provides execution support for string-based SQL statements as well as</span>
<span class="sd">    :class:`.ClauseElement`, :class:`.Compiled` and :class:`.DefaultGenerator`</span>
<span class="sd">    objects. Provides a :meth:`begin` method to return :class:`.Transaction`</span>
<span class="sd">    objects.</span>

<span class="sd">    The Connection object is **not** thread-safe.  While a Connection can be</span>
<span class="sd">    shared among threads using properly synchronized access, it is still</span>
<span class="sd">    possible that the underlying DBAPI connection may not support shared</span>
<span class="sd">    access between threads.  Check the DBAPI documentation for details.</span>

<span class="sd">    The Connection object represents a single dbapi connection checked out</span>
<span class="sd">    from the connection pool. In this state, the connection pool has no affect</span>
<span class="sd">    upon the connection, including its expiration or timeout state. For the</span>
<span class="sd">    connection pool to properly manage connections, connections should be</span>
<span class="sd">    returned to the connection pool (i.e. ``connection.close()``) whenever the</span>
<span class="sd">    connection is not in use.</span>

<span class="sd">    .. index::</span>
<span class="sd">      single: thread safety; Connection</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">schema_for_object</span> <span class="o">=</span> <span class="n">schema</span><span class="o">.</span><span class="n">_schema_getter</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;Return the &quot;.schema&quot; attribute for an object.</span>

<span class="sd">    Used for :class:`.Table`, :class:`.Sequence` and similar objects,</span>
<span class="sd">    and takes into account</span>
<span class="sd">    the :paramref:`.Connection.execution_options.schema_translate_map`</span>
<span class="sd">    parameter.</span>

<span class="sd">      .. versionadded:: 1.1</span>

<span class="sd">      .. seealso::</span>

<span class="sd">          :ref:`schema_translating`</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">engine</span><span class="p">,</span> <span class="n">connection</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">close_with_result</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">_branch_from</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">_execution_options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">_dispatch</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">_has_events</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct a new Connection.</span>

<span class="sd">        The constructor here is not public and is only called only by an</span>
<span class="sd">        :class:`.Engine`. See :meth:`.Engine.connect` and</span>
<span class="sd">        :meth:`.Engine.contextual_connect` methods.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">engine</span> <span class="o">=</span> <span class="n">engine</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dialect</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">dialect</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__branch_from</span> <span class="o">=</span> <span class="n">_branch_from</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__branch</span> <span class="o">=</span> <span class="n">_branch_from</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">_branch_from</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__connection</span> <span class="o">=</span> <span class="n">connection</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_execution_options</span> <span class="o">=</span> <span class="n">_execution_options</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_echo</span> <span class="o">=</span> <span class="n">_branch_from</span><span class="o">.</span><span class="n">_echo</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">should_close_with_result</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span> <span class="o">=</span> <span class="n">_dispatch</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_has_events</span> <span class="o">=</span> <span class="n">_branch_from</span><span class="o">.</span><span class="n">_has_events</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">schema_for_object</span> <span class="o">=</span> <span class="n">_branch_from</span><span class="o">.</span><span class="n">schema_for_object</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__connection</span> <span class="o">=</span> <span class="n">connection</span> \
                <span class="k">if</span> <span class="n">connection</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">engine</span><span class="o">.</span><span class="n">raw_connection</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__transaction</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__savepoint_seq</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">should_close_with_result</span> <span class="o">=</span> <span class="n">close_with_result</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__invalid</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__can_reconnect</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_echo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">_should_log_info</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">_has_events</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># if _has_events is sent explicitly as False,</span>
                <span class="c1"># then don&#39;t join the dispatch of the engine; we don&#39;t</span>
                <span class="c1"># want to handle any of the engine&#39;s events in that case.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">_join</span><span class="p">(</span><span class="n">engine</span><span class="o">.</span><span class="n">dispatch</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_has_events</span> <span class="o">=</span> <span class="n">_has_events</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="n">_has_events</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">engine</span><span class="o">.</span><span class="n">_has_events</span><span class="p">)</span>

            <span class="k">assert</span> <span class="ow">not</span> <span class="n">_execution_options</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_execution_options</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">_execution_options</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_events</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">_has_events</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">engine_connect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__branch</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_branch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new Connection which references this Connection&#39;s</span>
<span class="sd">        engine and connection; but does not have close_with_result enabled,</span>
<span class="sd">        and also whose close() method does nothing.</span>

<span class="sd">        The Core uses this very sparingly, only in the case of</span>
<span class="sd">        custom SQL default functions that are to be INSERTed as the</span>
<span class="sd">        primary key of a row where we need to get the value back, so we have</span>
<span class="sd">        to invoke it distinctly - this is a very uncommon case.</span>

<span class="sd">        Userland code accesses _branch() when the connect() or</span>
<span class="sd">        contextual_connect() methods are called.  The branched connection</span>
<span class="sd">        acts as much as possible like the parent, except that it stays</span>
<span class="sd">        connected when a close() event occurs.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__branch_from</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__branch_from</span><span class="o">.</span><span class="n">_branch</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">_connection_cls</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__connection</span><span class="p">,</span>
                <span class="n">_branch_from</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">_execution_options</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_execution_options</span><span class="p">,</span>
                <span class="n">_has_events</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_has_events</span><span class="p">,</span>
                <span class="n">_dispatch</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_root</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return the &#39;root&#39; connection.</span>

<span class="sd">        Returns &#39;self&#39; if this connection is not a branch, else</span>
<span class="sd">        returns the root connection from which we ultimately branched.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__branch_from</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__branch_from</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_clone</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a shallow copy of this Connection.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
        <span class="n">c</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">c</span>

    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">execution_options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">opt</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Set non-SQL options for the connection which take effect</span>
<span class="sd">        during execution.</span>

<span class="sd">        The method returns a copy of this :class:`.Connection` which references</span>
<span class="sd">        the same underlying DBAPI connection, but also defines the given</span>
<span class="sd">        execution options which will take effect for a call to</span>
<span class="sd">        :meth:`execute`. As the new :class:`.Connection` references the same</span>
<span class="sd">        underlying resource, it&#39;s usually a good idea to ensure that the copies</span>
<span class="sd">        will be discarded immediately, which is implicit if used as in::</span>

<span class="sd">            result = connection.execution_options(stream_results=True).\</span>
<span class="sd">                                execute(stmt)</span>

<span class="sd">        Note that any key/value can be passed to</span>
<span class="sd">        :meth:`.Connection.execution_options`, and it will be stored in the</span>
<span class="sd">        ``_execution_options`` dictionary of the :class:`.Connection`.   It</span>
<span class="sd">        is suitable for usage by end-user schemes to communicate with</span>
<span class="sd">        event listeners, for example.</span>

<span class="sd">        The keywords that are currently recognized by SQLAlchemy itself</span>
<span class="sd">        include all those listed under :meth:`.Executable.execution_options`,</span>
<span class="sd">        as well as others that are specific to :class:`.Connection`.</span>

<span class="sd">        :param autocommit: Available on: Connection, statement.</span>
<span class="sd">          When True, a COMMIT will be invoked after execution</span>
<span class="sd">          when executed in &#39;autocommit&#39; mode, i.e. when an explicit</span>
<span class="sd">          transaction is not begun on the connection. Note that DBAPI</span>
<span class="sd">          connections by default are always in a transaction - SQLAlchemy uses</span>
<span class="sd">          rules applied to different kinds of statements to determine if</span>
<span class="sd">          COMMIT will be invoked in order to provide its &quot;autocommit&quot; feature.</span>
<span class="sd">          Typically, all INSERT/UPDATE/DELETE statements as well as</span>
<span class="sd">          CREATE/DROP statements have autocommit behavior enabled; SELECT</span>
<span class="sd">          constructs do not. Use this option when invoking a SELECT or other</span>
<span class="sd">          specific SQL construct where COMMIT is desired (typically when</span>
<span class="sd">          calling stored procedures and such), and an explicit</span>
<span class="sd">          transaction is not in progress.</span>

<span class="sd">        :param compiled_cache: Available on: Connection.</span>
<span class="sd">          A dictionary where :class:`.Compiled` objects</span>
<span class="sd">          will be cached when the :class:`.Connection` compiles a clause</span>
<span class="sd">          expression into a :class:`.Compiled` object.</span>
<span class="sd">          It is the user&#39;s responsibility to</span>
<span class="sd">          manage the size of this dictionary, which will have keys</span>
<span class="sd">          corresponding to the dialect, clause element, the column</span>
<span class="sd">          names within the VALUES or SET clause of an INSERT or UPDATE,</span>
<span class="sd">          as well as the &quot;batch&quot; mode for an INSERT or UPDATE statement.</span>
<span class="sd">          The format of this dictionary is not guaranteed to stay the</span>
<span class="sd">          same in future releases.</span>

<span class="sd">          Note that the ORM makes use of its own &quot;compiled&quot; caches for</span>
<span class="sd">          some operations, including flush operations.  The caching</span>
<span class="sd">          used by the ORM internally supersedes a cache dictionary</span>
<span class="sd">          specified here.</span>

<span class="sd">        :param isolation_level: Available on: :class:`.Connection`.</span>
<span class="sd">          Set the transaction isolation level for</span>
<span class="sd">          the lifespan of this :class:`.Connection` object (*not* the</span>
<span class="sd">          underlying DBAPI connection, for which the level is reset</span>
<span class="sd">          to its original setting upon termination of this</span>
<span class="sd">          :class:`.Connection` object).</span>

<span class="sd">          Valid values include</span>
<span class="sd">          those string values accepted by the</span>
<span class="sd">          :paramref:`.create_engine.isolation_level`</span>
<span class="sd">          parameter passed to :func:`.create_engine`.  These levels are</span>
<span class="sd">          semi-database specific; see individual dialect documentation for</span>
<span class="sd">          valid levels.</span>

<span class="sd">          Note that this option necessarily affects the underlying</span>
<span class="sd">          DBAPI connection for the lifespan of the originating</span>
<span class="sd">          :class:`.Connection`, and is not per-execution. This</span>
<span class="sd">          setting is not removed until the underlying DBAPI connection</span>
<span class="sd">          is returned to the connection pool, i.e.</span>
<span class="sd">          the :meth:`.Connection.close` method is called.</span>

<span class="sd">          .. warning::  The ``isolation_level`` execution option should</span>
<span class="sd">             **not** be used when a transaction is already established, that</span>
<span class="sd">             is, the :meth:`.Connection.begin` method or similar has been</span>
<span class="sd">             called.  A database cannot change the isolation level on a</span>
<span class="sd">             transaction in progress, and different DBAPIs and/or</span>
<span class="sd">             SQLAlchemy dialects may implicitly roll back or commit</span>
<span class="sd">             the transaction, or not affect the connection at all.</span>

<span class="sd">             .. versionchanged:: 0.9.9 A warning is emitted when the</span>
<span class="sd">                ``isolation_level`` execution option is used after a</span>
<span class="sd">                transaction has been started with :meth:`.Connection.begin`</span>
<span class="sd">                or similar.</span>

<span class="sd">          .. note:: The ``isolation_level`` execution option is implicitly</span>
<span class="sd">             reset if the :class:`.Connection` is invalidated, e.g. via</span>
<span class="sd">             the :meth:`.Connection.invalidate` method, or if a</span>
<span class="sd">             disconnection error occurs.  The new connection produced after</span>
<span class="sd">             the invalidation will not have the isolation level re-applied</span>
<span class="sd">             to it automatically.</span>

<span class="sd">          .. seealso::</span>

<span class="sd">                :paramref:`.create_engine.isolation_level`</span>
<span class="sd">                - set per :class:`.Engine` isolation level</span>

<span class="sd">                :meth:`.Connection.get_isolation_level` - view current level</span>

<span class="sd">                :ref:`SQLite Transaction Isolation &lt;sqlite_isolation_level&gt;`</span>

<span class="sd">                :ref:`PostgreSQL Transaction Isolation &lt;postgresql_isolation_level&gt;`</span>

<span class="sd">                :ref:`MySQL Transaction Isolation &lt;mysql_isolation_level&gt;`</span>

<span class="sd">                :ref:`SQL Server Transaction Isolation &lt;mssql_isolation_level&gt;`</span>

<span class="sd">                :ref:`session_transaction_isolation` - for the ORM</span>

<span class="sd">        :param no_parameters: When ``True``, if the final parameter</span>
<span class="sd">          list or dictionary is totally empty, will invoke the</span>
<span class="sd">          statement on the cursor as ``cursor.execute(statement)``,</span>
<span class="sd">          not passing the parameter collection at all.</span>
<span class="sd">          Some DBAPIs such as psycopg2 and mysql-python consider</span>
<span class="sd">          percent signs as significant only when parameters are</span>
<span class="sd">          present; this option allows code to generate SQL</span>
<span class="sd">          containing percent signs (and possibly other characters)</span>
<span class="sd">          that is neutral regarding whether it&#39;s executed by the DBAPI</span>
<span class="sd">          or piped into a script that&#39;s later invoked by</span>
<span class="sd">          command line tools.</span>

<span class="sd">          .. versionadded:: 0.7.6</span>

<span class="sd">        :param stream_results: Available on: Connection, statement.</span>
<span class="sd">          Indicate to the dialect that results should be</span>
<span class="sd">          &quot;streamed&quot; and not pre-buffered, if possible.  This is a limitation</span>
<span class="sd">          of many DBAPIs.  The flag is currently understood only by the</span>
<span class="sd">          psycopg2, mysqldb and pymysql dialects.</span>

<span class="sd">        :param schema_translate_map: Available on: Connection, Engine.</span>
<span class="sd">          A dictionary mapping schema names to schema names, that will be</span>
<span class="sd">          applied to the :paramref:`.Table.schema` element of each</span>
<span class="sd">          :class:`.Table` encountered when SQL or DDL expression elements</span>
<span class="sd">          are compiled into strings; the resulting schema name will be</span>
<span class="sd">          converted based on presence in the map of the original name.</span>

<span class="sd">          .. versionadded:: 1.1</span>

<span class="sd">          .. seealso::</span>

<span class="sd">            :ref:`schema_translating`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone</span><span class="p">()</span>
        <span class="n">c</span><span class="o">.</span><span class="n">_execution_options</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">_execution_options</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">opt</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_events</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">_has_events</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">set_connection_execution_options</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">opt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dialect</span><span class="o">.</span><span class="n">set_connection_execution_options</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">opt</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">c</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">closed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if this connection is closed.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="s1">&#39;_Connection__connection&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> \
            <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__can_reconnect</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">invalidated</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if this connection was invalidated.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_root</span><span class="o">.</span><span class="n">__invalid</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">connection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The underlying DB-API connection managed by this Connection.</span>

<span class="sd">        .. seealso::</span>


<span class="sd">            :ref:`dbapi_connections`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__connection</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c1"># escape &quot;except AttributeError&quot; before revalidating</span>
            <span class="c1"># to prevent misleading stacktraces in Py3K</span>
            <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_revalidate_connection</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">BaseException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle_dbapi_exception</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_isolation_level</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the current isolation level assigned to this</span>
<span class="sd">        :class:`.Connection`.</span>

<span class="sd">        This will typically be the default isolation level as determined</span>
<span class="sd">        by the dialect, unless if the</span>
<span class="sd">        :paramref:`.Connection.execution_options.isolation_level`</span>
<span class="sd">        feature has been used to alter the isolation level on a</span>
<span class="sd">        per-:class:`.Connection` basis.</span>

<span class="sd">        This attribute will typically perform a live SQL operation in order</span>
<span class="sd">        to procure the current isolation level, so the value returned is the</span>
<span class="sd">        actual level on the underlying DBAPI connection regardless of how</span>
<span class="sd">        this state was set.  Compare to the</span>
<span class="sd">        :attr:`.Connection.default_isolation_level` accessor</span>
<span class="sd">        which returns the dialect-level setting without performing a SQL</span>
<span class="sd">        query.</span>

<span class="sd">        .. versionadded:: 0.9.9</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :attr:`.Connection.default_isolation_level` - view default level</span>

<span class="sd">            :paramref:`.create_engine.isolation_level`</span>
<span class="sd">            - set per :class:`.Engine` isolation level</span>

<span class="sd">            :paramref:`.Connection.execution_options.isolation_level`</span>
<span class="sd">            - set per :class:`.Connection` isolation level</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dialect</span><span class="o">.</span><span class="n">get_isolation_level</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">BaseException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle_dbapi_exception</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">default_isolation_level</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The default isolation level assigned to this :class:`.Connection`.</span>

<span class="sd">        This is the isolation level setting that the :class:`.Connection`</span>
<span class="sd">        has when first procured via the :meth:`.Engine.connect` method.</span>
<span class="sd">        This level stays in place until the</span>
<span class="sd">        :paramref:`.Connection.execution_options.isolation_level` is used</span>
<span class="sd">        to change the setting on a per-:class:`.Connection` basis.</span>

<span class="sd">        Unlike :meth:`.Connection.get_isolation_level`, this attribute is set</span>
<span class="sd">        ahead of time from the first connection procured by the dialect,</span>
<span class="sd">        so SQL query is not invoked when this accessor is called.</span>

<span class="sd">        .. versionadded:: 0.9.9</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.Connection.get_isolation_level` - view current level</span>

<span class="sd">            :paramref:`.create_engine.isolation_level`</span>
<span class="sd">            - set per :class:`.Engine` isolation level</span>

<span class="sd">            :paramref:`.Connection.execution_options.isolation_level`</span>
<span class="sd">            - set per :class:`.Connection` isolation level</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dialect</span><span class="o">.</span><span class="n">default_isolation_level</span>

    <span class="k">def</span> <span class="nf">_revalidate_connection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__branch_from</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__branch_from</span><span class="o">.</span><span class="n">_revalidate_connection</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__can_reconnect</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">__invalid</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__transaction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                    <span class="s2">&quot;Can&#39;t reconnect until invalid &quot;</span>
                    <span class="s2">&quot;transaction is rolled back&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__connection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">raw_connection</span><span class="p">(</span><span class="n">_connection</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__invalid</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__connection</span>
        <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">ResourceClosedError</span><span class="p">(</span><span class="s2">&quot;This Connection is closed&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_connection_is_valid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># use getattr() for is_valid to support exceptions raised in</span>
        <span class="c1"># dialect initializer, where the connection is not wrapped in</span>
        <span class="c1"># _ConnectionFairy</span>

        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__connection</span><span class="p">,</span> <span class="s1">&#39;is_valid&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_still_open_and_connection_is_valid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> \
            <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span> <span class="ow">and</span> \
            <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">invalidated</span> <span class="ow">and</span> \
            <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__connection</span><span class="p">,</span> <span class="s1">&#39;is_valid&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Info dictionary associated with the underlying DBAPI connection</span>
<span class="sd">        referred to by this :class:`.Connection`, allowing user-defined</span>
<span class="sd">        data to be associated with the connection.</span>

<span class="sd">        The data here will follow along with the DBAPI connection including</span>
<span class="sd">        after it is returned to the connection pool and used again</span>
<span class="sd">        in subsequent instances of :class:`.Connection`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">info</span>

    <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a branched version of this :class:`.Connection`.</span>

<span class="sd">        The :meth:`.Connection.close` method on the returned</span>
<span class="sd">        :class:`.Connection` can be called and this</span>
<span class="sd">        :class:`.Connection` will remain open.</span>

<span class="sd">        This method provides usage symmetry with</span>
<span class="sd">        :meth:`.Engine.connect`, including for usage</span>
<span class="sd">        with context managers.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_branch</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">contextual_connect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a branched version of this :class:`.Connection`.</span>

<span class="sd">        The :meth:`.Connection.close` method on the returned</span>
<span class="sd">        :class:`.Connection` can be called and this</span>
<span class="sd">        :class:`.Connection` will remain open.</span>

<span class="sd">        This method provides usage symmetry with</span>
<span class="sd">        :meth:`.Engine.contextual_connect`, including for usage</span>
<span class="sd">        with context managers.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_branch</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">invalidate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exception</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Invalidate the underlying DBAPI connection associated with</span>
<span class="sd">        this :class:`.Connection`.</span>

<span class="sd">        The underlying DBAPI connection is literally closed (if</span>
<span class="sd">        possible), and is discarded.  Its source connection pool will</span>
<span class="sd">        typically lazily create a new connection to replace it.</span>

<span class="sd">        Upon the next use (where &quot;use&quot; typically means using the</span>
<span class="sd">        :meth:`.Connection.execute` method or similar),</span>
<span class="sd">        this :class:`.Connection` will attempt to</span>
<span class="sd">        procure a new DBAPI connection using the services of the</span>
<span class="sd">        :class:`.Pool` as a source of connectivity (e.g. a &quot;reconnection&quot;).</span>

<span class="sd">        If a transaction was in progress (e.g. the</span>
<span class="sd">        :meth:`.Connection.begin` method has been called) when</span>
<span class="sd">        :meth:`.Connection.invalidate` method is called, at the DBAPI</span>
<span class="sd">        level all state associated with this transaction is lost, as</span>
<span class="sd">        the DBAPI connection is closed.  The :class:`.Connection`</span>
<span class="sd">        will not allow a reconnection to proceed until the</span>
<span class="sd">        :class:`.Transaction` object is ended, by calling the</span>
<span class="sd">        :meth:`.Transaction.rollback` method; until that point, any attempt at</span>
<span class="sd">        continuing to use the :class:`.Connection` will raise an</span>
<span class="sd">        :class:`~sqlalchemy.exc.InvalidRequestError`.</span>
<span class="sd">        This is to prevent applications from accidentally</span>
<span class="sd">        continuing an ongoing transactional operations despite the</span>
<span class="sd">        fact that the transaction has been lost due to an</span>
<span class="sd">        invalidation.</span>

<span class="sd">        The :meth:`.Connection.invalidate` method, just like auto-invalidation,</span>
<span class="sd">        will at the connection pool level invoke the</span>
<span class="sd">        :meth:`.PoolEvents.invalidate` event.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`pool_connection_invalidation`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">invalidated</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">ResourceClosedError</span><span class="p">(</span><span class="s2">&quot;This Connection is closed&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_root</span><span class="o">.</span><span class="n">_connection_is_valid</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_root</span><span class="o">.</span><span class="n">__connection</span><span class="o">.</span><span class="n">invalidate</span><span class="p">(</span><span class="n">exception</span><span class="p">)</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_root</span><span class="o">.</span><span class="n">__connection</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_root</span><span class="o">.</span><span class="n">__invalid</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">detach</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Detach the underlying DB-API connection from its connection pool.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            with engine.connect() as conn:</span>
<span class="sd">                conn.detach()</span>
<span class="sd">                conn.execute(&quot;SET search_path TO schema1, schema2&quot;)</span>

<span class="sd">                # work with connection</span>

<span class="sd">            # connection is fully closed (since we used &quot;with:&quot;, can</span>
<span class="sd">            # also call .close())</span>

<span class="sd">        This :class:`.Connection` instance will remain usable.  When closed</span>
<span class="sd">        (or exited from a context manager context as above),</span>
<span class="sd">        the DB-API connection will be literally closed and not</span>
<span class="sd">        returned to its originating pool.</span>

<span class="sd">        This method can be used to insulate the rest of an application</span>
<span class="sd">        from a modified state on a connection (such as a transaction</span>
<span class="sd">        isolation level or similar).</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__connection</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">begin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Begin a transaction and return a transaction handle.</span>

<span class="sd">        The returned object is an instance of :class:`.Transaction`.</span>
<span class="sd">        This object represents the &quot;scope&quot; of the transaction,</span>
<span class="sd">        which completes when either the :meth:`.Transaction.rollback`</span>
<span class="sd">        or :meth:`.Transaction.commit` method is called.</span>

<span class="sd">        Nested calls to :meth:`.begin` on the same :class:`.Connection`</span>
<span class="sd">        will return new :class:`.Transaction` objects that represent</span>
<span class="sd">        an emulated transaction within the scope of the enclosing</span>
<span class="sd">        transaction, that is::</span>

<span class="sd">            trans = conn.begin()   # outermost transaction</span>
<span class="sd">            trans2 = conn.begin()  # &quot;nested&quot;</span>
<span class="sd">            trans2.commit()        # does nothing</span>
<span class="sd">            trans.commit()         # actually commits</span>

<span class="sd">        Calls to :meth:`.Transaction.commit` only have an effect</span>
<span class="sd">        when invoked via the outermost :class:`.Transaction` object, though the</span>
<span class="sd">        :meth:`.Transaction.rollback` method of any of the</span>
<span class="sd">        :class:`.Transaction` objects will roll back the</span>
<span class="sd">        transaction.</span>

<span class="sd">        See also:</span>

<span class="sd">        :meth:`.Connection.begin_nested` - use a SAVEPOINT</span>

<span class="sd">        :meth:`.Connection.begin_twophase` - use a two phase /XID transaction</span>

<span class="sd">        :meth:`.Engine.begin` - context manager available from</span>
<span class="sd">        :class:`.Engine`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__branch_from</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__branch_from</span><span class="o">.</span><span class="n">begin</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__transaction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__transaction</span> <span class="o">=</span> <span class="n">RootTransaction</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__transaction</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Transaction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__transaction</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">begin_nested</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Begin a nested transaction and return a transaction handle.</span>

<span class="sd">        The returned object is an instance of :class:`.NestedTransaction`.</span>

<span class="sd">        Nested transactions require SAVEPOINT support in the</span>
<span class="sd">        underlying database.  Any transaction in the hierarchy may</span>
<span class="sd">        ``commit`` and ``rollback``, however the outermost transaction</span>
<span class="sd">        still controls the overall ``commit`` or ``rollback`` of the</span>
<span class="sd">        transaction of a whole.</span>

<span class="sd">        See also :meth:`.Connection.begin`,</span>
<span class="sd">        :meth:`.Connection.begin_twophase`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__branch_from</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__branch_from</span><span class="o">.</span><span class="n">begin_nested</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__transaction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__transaction</span> <span class="o">=</span> <span class="n">RootTransaction</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__transaction</span> <span class="o">=</span> <span class="n">NestedTransaction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__transaction</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__transaction</span>

    <span class="k">def</span> <span class="nf">begin_twophase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xid</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Begin a two-phase or XA transaction and return a transaction</span>
<span class="sd">        handle.</span>

<span class="sd">        The returned object is an instance of :class:`.TwoPhaseTransaction`,</span>
<span class="sd">        which in addition to the methods provided by</span>
<span class="sd">        :class:`.Transaction`, also provides a</span>
<span class="sd">        :meth:`~.TwoPhaseTransaction.prepare` method.</span>

<span class="sd">        :param xid: the two phase transaction id.  If not supplied, a</span>
<span class="sd">          random id will be generated.</span>

<span class="sd">        See also :meth:`.Connection.begin`,</span>
<span class="sd">        :meth:`.Connection.begin_twophase`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__branch_from</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__branch_from</span><span class="o">.</span><span class="n">begin_twophase</span><span class="p">(</span><span class="n">xid</span><span class="o">=</span><span class="n">xid</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__transaction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot start a two phase transaction when a transaction &quot;</span>
                <span class="s2">&quot;is already in progress.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">xid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">dialect</span><span class="o">.</span><span class="n">create_xid</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__transaction</span> <span class="o">=</span> <span class="n">TwoPhaseTransaction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xid</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__transaction</span>

    <span class="k">def</span> <span class="nf">recover_twophase</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">dialect</span><span class="o">.</span><span class="n">do_recover_twophase</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rollback_prepared</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xid</span><span class="p">,</span> <span class="n">recover</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">dialect</span><span class="o">.</span><span class="n">do_rollback_twophase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xid</span><span class="p">,</span> <span class="n">recover</span><span class="o">=</span><span class="n">recover</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">commit_prepared</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xid</span><span class="p">,</span> <span class="n">recover</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">dialect</span><span class="o">.</span><span class="n">do_commit_twophase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xid</span><span class="p">,</span> <span class="n">recover</span><span class="o">=</span><span class="n">recover</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">in_transaction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if a transaction is in progress.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_root</span><span class="o">.</span><span class="n">__transaction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_begin_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transaction</span><span class="p">):</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__branch_from</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_echo</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;BEGIN (implicit)&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_events</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">_has_events</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">begin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">dialect</span><span class="o">.</span><span class="n">do_begin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">_reset_agent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">_reset_agent</span> <span class="o">=</span> <span class="n">transaction</span>
        <span class="k">except</span> <span class="ne">BaseException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle_dbapi_exception</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_rollback_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__branch_from</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_events</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">_has_events</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">rollback</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_still_open_and_connection_is_valid</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_echo</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;ROLLBACK&quot;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">dialect</span><span class="o">.</span><span class="n">do_rollback</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">BaseException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_handle_dbapi_exception</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__invalid</span> <span class="ow">and</span> \
                        <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">_reset_agent</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">__transaction</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">_reset_agent</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__transaction</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__transaction</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_commit_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">autocommit</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__branch_from</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_events</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">_has_events</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">commit</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_echo</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;COMMIT&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">dialect</span><span class="o">.</span><span class="n">do_commit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">BaseException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle_dbapi_exception</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__invalid</span> <span class="ow">and</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">_reset_agent</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">__transaction</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">_reset_agent</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__transaction</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_savepoint_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__branch_from</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_events</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">_has_events</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">savepoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__savepoint_seq</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;sa_savepoint_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">__savepoint_seq</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_still_open_and_connection_is_valid</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">dialect</span><span class="o">.</span><span class="n">do_savepoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">_rollback_to_savepoint_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__branch_from</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_events</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">_has_events</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">rollback_savepoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_still_open_and_connection_is_valid</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">dialect</span><span class="o">.</span><span class="n">do_rollback_to_savepoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__transaction</span> <span class="o">=</span> <span class="n">context</span>

    <span class="k">def</span> <span class="nf">_release_savepoint_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__branch_from</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_events</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">_has_events</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">release_savepoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_still_open_and_connection_is_valid</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">dialect</span><span class="o">.</span><span class="n">do_release_savepoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__transaction</span> <span class="o">=</span> <span class="n">context</span>

    <span class="k">def</span> <span class="nf">_begin_twophase_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transaction</span><span class="p">):</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__branch_from</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_echo</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;BEGIN TWOPHASE (implicit)&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_events</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">_has_events</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">begin_twophase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transaction</span><span class="o">.</span><span class="n">xid</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_still_open_and_connection_is_valid</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">dialect</span><span class="o">.</span><span class="n">do_begin_twophase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transaction</span><span class="o">.</span><span class="n">xid</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">_reset_agent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">_reset_agent</span> <span class="o">=</span> <span class="n">transaction</span>

    <span class="k">def</span> <span class="nf">_prepare_twophase_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xid</span><span class="p">):</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__branch_from</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_events</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">_has_events</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">prepare_twophase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xid</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_still_open_and_connection_is_valid</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__transaction</span><span class="p">,</span> <span class="n">TwoPhaseTransaction</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">dialect</span><span class="o">.</span><span class="n">do_prepare_twophase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xid</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_rollback_twophase_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xid</span><span class="p">,</span> <span class="n">is_prepared</span><span class="p">):</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__branch_from</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_events</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">_has_events</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">rollback_twophase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xid</span><span class="p">,</span> <span class="n">is_prepared</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_still_open_and_connection_is_valid</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__transaction</span><span class="p">,</span> <span class="n">TwoPhaseTransaction</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">dialect</span><span class="o">.</span><span class="n">do_rollback_twophase</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">,</span> <span class="n">xid</span><span class="p">,</span> <span class="n">is_prepared</span><span class="p">)</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">_reset_agent</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">__transaction</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">_reset_agent</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__transaction</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__transaction</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_commit_twophase_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xid</span><span class="p">,</span> <span class="n">is_prepared</span><span class="p">):</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__branch_from</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_events</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">_has_events</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">commit_twophase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xid</span><span class="p">,</span> <span class="n">is_prepared</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_still_open_and_connection_is_valid</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__transaction</span><span class="p">,</span> <span class="n">TwoPhaseTransaction</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">dialect</span><span class="o">.</span><span class="n">do_commit_twophase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xid</span><span class="p">,</span> <span class="n">is_prepared</span><span class="p">)</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">_reset_agent</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">__transaction</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">_reset_agent</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__transaction</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__transaction</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_autorollback</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_root</span><span class="o">.</span><span class="n">in_transaction</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_root</span><span class="o">.</span><span class="n">_rollback_impl</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Close this :class:`.Connection`.</span>

<span class="sd">        This results in a release of the underlying database</span>
<span class="sd">        resources, that is, the DBAPI connection referenced</span>
<span class="sd">        internally. The DBAPI connection is typically restored</span>
<span class="sd">        back to the connection-holding :class:`.Pool` referenced</span>
<span class="sd">        by the :class:`.Engine` that produced this</span>
<span class="sd">        :class:`.Connection`. Any transactional state present on</span>
<span class="sd">        the DBAPI connection is also unconditionally released via</span>
<span class="sd">        the DBAPI connection&#39;s ``rollback()`` method, regardless</span>
<span class="sd">        of any :class:`.Transaction` object that may be</span>
<span class="sd">        outstanding with regards to this :class:`.Connection`.</span>

<span class="sd">        After :meth:`~.Connection.close` is called, the</span>
<span class="sd">        :class:`.Connection` is permanently in a closed state,</span>
<span class="sd">        and will allow no further operations.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__branch_from</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__connection</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__can_reconnect</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">return</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">conn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__connection</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="n">conn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">conn</span><span class="o">.</span><span class="n">_reset_agent</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">__transaction</span><span class="p">:</span>
                <span class="n">conn</span><span class="o">.</span><span class="n">_reset_agent</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># the close() process can end up invalidating us,</span>
            <span class="c1"># as the pool will call our transaction as the &quot;reset_agent&quot;</span>
            <span class="c1"># for rollback(), which can then cause an invalidation</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__invalid</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__connection</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__can_reconnect</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__transaction</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">object</span><span class="p">,</span> <span class="o">*</span><span class="n">multiparams</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Executes and returns the first column of the first row.</span>

<span class="sd">        The underlying result/cursor is closed after execution.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="o">*</span><span class="n">multiparams</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span><span class="o">.</span><span class="n">scalar</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">object</span><span class="p">,</span> <span class="o">*</span><span class="n">multiparams</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Executes a SQL statement construct and returns a</span>
<span class="sd">        :class:`.ResultProxy`.</span>

<span class="sd">        :param object: The statement to be executed.  May be</span>
<span class="sd">         one of:</span>

<span class="sd">         * a plain string</span>
<span class="sd">         * any :class:`.ClauseElement` construct that is also</span>
<span class="sd">           a subclass of :class:`.Executable`, such as a</span>
<span class="sd">           :func:`~.expression.select` construct</span>
<span class="sd">         * a :class:`.FunctionElement`, such as that generated</span>
<span class="sd">           by :data:`.func`, will be automatically wrapped in</span>
<span class="sd">           a SELECT statement, which is then executed.</span>
<span class="sd">         * a :class:`.DDLElement` object</span>
<span class="sd">         * a :class:`.DefaultGenerator` object</span>
<span class="sd">         * a :class:`.Compiled` object</span>

<span class="sd">        :param \*multiparams/\**params: represent bound parameter</span>
<span class="sd">         values to be used in the execution.   Typically,</span>
<span class="sd">         the format is either a collection of one or more</span>
<span class="sd">         dictionaries passed to \*multiparams::</span>

<span class="sd">             conn.execute(</span>
<span class="sd">                 table.insert(),</span>
<span class="sd">                 {&quot;id&quot;:1, &quot;value&quot;:&quot;v1&quot;},</span>
<span class="sd">                 {&quot;id&quot;:2, &quot;value&quot;:&quot;v2&quot;}</span>
<span class="sd">             )</span>

<span class="sd">         ...or individual key/values interpreted by \**params::</span>

<span class="sd">             conn.execute(</span>
<span class="sd">                 table.insert(), id=1, value=&quot;v1&quot;</span>
<span class="sd">             )</span>

<span class="sd">         In the case that a plain SQL string is passed, and the underlying</span>
<span class="sd">         DBAPI accepts positional bind parameters, a collection of tuples</span>
<span class="sd">         or individual values in \*multiparams may be passed::</span>

<span class="sd">             conn.execute(</span>
<span class="sd">                 &quot;INSERT INTO table (id, value) VALUES (?, ?)&quot;,</span>
<span class="sd">                 (1, &quot;v1&quot;), (2, &quot;v2&quot;)</span>
<span class="sd">             )</span>

<span class="sd">             conn.execute(</span>
<span class="sd">                 &quot;INSERT INTO table (id, value) VALUES (?, ?)&quot;,</span>
<span class="sd">                 1, &quot;v1&quot;</span>
<span class="sd">             )</span>

<span class="sd">         Note above, the usage of a question mark &quot;?&quot; or other</span>
<span class="sd">         symbol is contingent upon the &quot;paramstyle&quot; accepted by the DBAPI</span>
<span class="sd">         in use, which may be any of &quot;qmark&quot;, &quot;named&quot;, &quot;pyformat&quot;, &quot;format&quot;,</span>
<span class="sd">         &quot;numeric&quot;.   See `pep-249 &lt;http://www.python.org/dev/peps/pep-0249/&gt;`_</span>
<span class="sd">         for details on paramstyle.</span>

<span class="sd">         To execute a textual SQL statement which uses bound parameters in a</span>
<span class="sd">         DBAPI-agnostic way, use the :func:`~.expression.text` construct.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">util</span><span class="o">.</span><span class="n">string_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_execute_text</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">multiparams</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">meth</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="n">_execute_on_connection</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">ObjectNotExecutableError</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">multiparams</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_execute_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">multiparams</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Execute a sql.FunctionElement object.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_execute_clauseelement</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">select</span><span class="p">(),</span>
                                           <span class="n">multiparams</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_execute_default</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">default</span><span class="p">,</span> <span class="n">multiparams</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Execute a schema.ColumnDefault object.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_events</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">_has_events</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">before_execute</span><span class="p">:</span>
                <span class="n">default</span><span class="p">,</span> <span class="n">multiparams</span><span class="p">,</span> <span class="n">params</span> <span class="o">=</span> \
                    <span class="n">fn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">default</span><span class="p">,</span> <span class="n">multiparams</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">conn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__connection</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="c1"># escape &quot;except AttributeError&quot; before revalidating</span>
                <span class="c1"># to prevent misleading stacktraces in Py3K</span>
                <span class="n">conn</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">conn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">conn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_revalidate_connection</span><span class="p">()</span>

            <span class="n">dialect</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dialect</span>
            <span class="n">ctx</span> <span class="o">=</span> <span class="n">dialect</span><span class="o">.</span><span class="n">execution_ctx_cls</span><span class="o">.</span><span class="n">_init_default</span><span class="p">(</span>
                <span class="n">dialect</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">conn</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">BaseException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle_dbapi_exception</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">_exec_default</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">default</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">should_close_with_result</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_events</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">_has_events</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">after_execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                        <span class="n">default</span><span class="p">,</span> <span class="n">multiparams</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">ret</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">_execute_ddl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ddl</span><span class="p">,</span> <span class="n">multiparams</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Execute a schema.DDL object.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_events</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">_has_events</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">before_execute</span><span class="p">:</span>
                <span class="n">ddl</span><span class="p">,</span> <span class="n">multiparams</span><span class="p">,</span> <span class="n">params</span> <span class="o">=</span> \
                    <span class="n">fn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ddl</span><span class="p">,</span> <span class="n">multiparams</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>

        <span class="n">dialect</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dialect</span>

        <span class="n">compiled</span> <span class="o">=</span> <span class="n">ddl</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
            <span class="n">dialect</span><span class="o">=</span><span class="n">dialect</span><span class="p">,</span>
            <span class="n">schema_translate_map</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">schema_for_object</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">schema_for_object</span><span class="o">.</span><span class="n">is_default</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_execute_context</span><span class="p">(</span>
            <span class="n">dialect</span><span class="p">,</span>
            <span class="n">dialect</span><span class="o">.</span><span class="n">execution_ctx_cls</span><span class="o">.</span><span class="n">_init_ddl</span><span class="p">,</span>
            <span class="n">compiled</span><span class="p">,</span>
            <span class="kc">None</span><span class="p">,</span>
            <span class="n">compiled</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_events</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">_has_events</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">after_execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                        <span class="n">ddl</span><span class="p">,</span> <span class="n">multiparams</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">ret</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">_execute_clauseelement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elem</span><span class="p">,</span> <span class="n">multiparams</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Execute a sql.ClauseElement object.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_events</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">_has_events</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">before_execute</span><span class="p">:</span>
                <span class="n">elem</span><span class="p">,</span> <span class="n">multiparams</span><span class="p">,</span> <span class="n">params</span> <span class="o">=</span> \
                    <span class="n">fn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elem</span><span class="p">,</span> <span class="n">multiparams</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>

        <span class="n">distilled_params</span> <span class="o">=</span> <span class="n">_distill_params</span><span class="p">(</span><span class="n">multiparams</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">distilled_params</span><span class="p">:</span>
            <span class="c1"># note this is usually dict but we support RowProxy</span>
            <span class="c1"># as well; but dict.keys() as an iterable is OK</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="n">distilled_params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">dialect</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dialect</span>
        <span class="k">if</span> <span class="s1">&#39;compiled_cache&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_execution_options</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">dialect</span><span class="p">,</span> <span class="n">elem</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">keys</span><span class="p">)),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">schema_for_object</span><span class="o">.</span><span class="n">hash_key</span><span class="p">,</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">distilled_params</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
            <span class="p">)</span>
            <span class="n">compiled_sql</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_execution_options</span><span class="p">[</span><span class="s1">&#39;compiled_cache&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">compiled_sql</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">compiled_sql</span> <span class="o">=</span> <span class="n">elem</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
                    <span class="n">dialect</span><span class="o">=</span><span class="n">dialect</span><span class="p">,</span> <span class="n">column_keys</span><span class="o">=</span><span class="n">keys</span><span class="p">,</span>
                    <span class="n">inline</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">distilled_params</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="n">schema_translate_map</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">schema_for_object</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">schema_for_object</span><span class="o">.</span><span class="n">is_default</span> <span class="k">else</span> <span class="kc">None</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_execution_options</span><span class="p">[</span><span class="s1">&#39;compiled_cache&#39;</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">compiled_sql</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">compiled_sql</span> <span class="o">=</span> <span class="n">elem</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
                <span class="n">dialect</span><span class="o">=</span><span class="n">dialect</span><span class="p">,</span> <span class="n">column_keys</span><span class="o">=</span><span class="n">keys</span><span class="p">,</span>
                <span class="n">inline</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">distilled_params</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span>
                <span class="n">schema_translate_map</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">schema_for_object</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">schema_for_object</span><span class="o">.</span><span class="n">is_default</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_execute_context</span><span class="p">(</span>
            <span class="n">dialect</span><span class="p">,</span>
            <span class="n">dialect</span><span class="o">.</span><span class="n">execution_ctx_cls</span><span class="o">.</span><span class="n">_init_compiled</span><span class="p">,</span>
            <span class="n">compiled_sql</span><span class="p">,</span>
            <span class="n">distilled_params</span><span class="p">,</span>
            <span class="n">compiled_sql</span><span class="p">,</span> <span class="n">distilled_params</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_events</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">_has_events</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">after_execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                        <span class="n">elem</span><span class="p">,</span> <span class="n">multiparams</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">ret</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">_execute_compiled</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">compiled</span><span class="p">,</span> <span class="n">multiparams</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Execute a sql.Compiled object.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_events</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">_has_events</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">before_execute</span><span class="p">:</span>
                <span class="n">compiled</span><span class="p">,</span> <span class="n">multiparams</span><span class="p">,</span> <span class="n">params</span> <span class="o">=</span> \
                    <span class="n">fn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">compiled</span><span class="p">,</span> <span class="n">multiparams</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>

        <span class="n">dialect</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dialect</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="n">_distill_params</span><span class="p">(</span><span class="n">multiparams</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_execute_context</span><span class="p">(</span>
            <span class="n">dialect</span><span class="p">,</span>
            <span class="n">dialect</span><span class="o">.</span><span class="n">execution_ctx_cls</span><span class="o">.</span><span class="n">_init_compiled</span><span class="p">,</span>
            <span class="n">compiled</span><span class="p">,</span>
            <span class="n">parameters</span><span class="p">,</span>
            <span class="n">compiled</span><span class="p">,</span> <span class="n">parameters</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_events</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">_has_events</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">after_execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                        <span class="n">compiled</span><span class="p">,</span> <span class="n">multiparams</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">ret</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">_execute_text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">statement</span><span class="p">,</span> <span class="n">multiparams</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Execute a string SQL statement.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_events</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">_has_events</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">before_execute</span><span class="p">:</span>
                <span class="n">statement</span><span class="p">,</span> <span class="n">multiparams</span><span class="p">,</span> <span class="n">params</span> <span class="o">=</span> \
                    <span class="n">fn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">statement</span><span class="p">,</span> <span class="n">multiparams</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>

        <span class="n">dialect</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dialect</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="n">_distill_params</span><span class="p">(</span><span class="n">multiparams</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_execute_context</span><span class="p">(</span>
            <span class="n">dialect</span><span class="p">,</span>
            <span class="n">dialect</span><span class="o">.</span><span class="n">execution_ctx_cls</span><span class="o">.</span><span class="n">_init_statement</span><span class="p">,</span>
            <span class="n">statement</span><span class="p">,</span>
            <span class="n">parameters</span><span class="p">,</span>
            <span class="n">statement</span><span class="p">,</span> <span class="n">parameters</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_events</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">_has_events</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">after_execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                        <span class="n">statement</span><span class="p">,</span> <span class="n">multiparams</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">ret</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">_execute_context</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dialect</span><span class="p">,</span> <span class="n">constructor</span><span class="p">,</span>
                         <span class="n">statement</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span>
                         <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an :class:`.ExecutionContext` and execute, returning</span>
<span class="sd">        a :class:`.ResultProxy`.&quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">conn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__connection</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="c1"># escape &quot;except AttributeError&quot; before revalidating</span>
                <span class="c1"># to prevent misleading stacktraces in Py3K</span>
                <span class="n">conn</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">conn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">conn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_revalidate_connection</span><span class="p">()</span>

            <span class="n">context</span> <span class="o">=</span> <span class="n">constructor</span><span class="p">(</span><span class="n">dialect</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">conn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">BaseException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle_dbapi_exception</span><span class="p">(</span>
                <span class="n">e</span><span class="p">,</span>
                <span class="n">util</span><span class="o">.</span><span class="n">text_type</span><span class="p">(</span><span class="n">statement</span><span class="p">),</span> <span class="n">parameters</span><span class="p">,</span>
                <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">compiled</span><span class="p">:</span>
            <span class="n">context</span><span class="o">.</span><span class="n">pre_exec</span><span class="p">()</span>

        <span class="n">cursor</span><span class="p">,</span> <span class="n">statement</span><span class="p">,</span> <span class="n">parameters</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">cursor</span><span class="p">,</span> \
            <span class="n">context</span><span class="o">.</span><span class="n">statement</span><span class="p">,</span> \
            <span class="n">context</span><span class="o">.</span><span class="n">parameters</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">context</span><span class="o">.</span><span class="n">executemany</span><span class="p">:</span>
            <span class="n">parameters</span> <span class="o">=</span> <span class="n">parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_events</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">_has_events</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">before_cursor_execute</span><span class="p">:</span>
                <span class="n">statement</span><span class="p">,</span> <span class="n">parameters</span> <span class="o">=</span> \
                    <span class="n">fn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cursor</span><span class="p">,</span> <span class="n">statement</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span>
                       <span class="n">context</span><span class="p">,</span> <span class="n">context</span><span class="o">.</span><span class="n">executemany</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_echo</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">statement</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">sql_util</span><span class="o">.</span><span class="n">_repr_params</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="n">batches</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="n">evt_handled</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">executemany</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dialect</span><span class="o">.</span><span class="n">_has_events</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dialect</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">do_executemany</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">fn</span><span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="n">statement</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
                            <span class="n">evt_handled</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="k">break</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">evt_handled</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dialect</span><span class="o">.</span><span class="n">do_executemany</span><span class="p">(</span>
                        <span class="n">cursor</span><span class="p">,</span>
                        <span class="n">statement</span><span class="p">,</span>
                        <span class="n">parameters</span><span class="p">,</span>
                        <span class="n">context</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">parameters</span> <span class="ow">and</span> <span class="n">context</span><span class="o">.</span><span class="n">no_parameters</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dialect</span><span class="o">.</span><span class="n">_has_events</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dialect</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">do_execute_no_params</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">fn</span><span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="n">statement</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
                            <span class="n">evt_handled</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="k">break</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">evt_handled</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dialect</span><span class="o">.</span><span class="n">do_execute_no_params</span><span class="p">(</span>
                        <span class="n">cursor</span><span class="p">,</span>
                        <span class="n">statement</span><span class="p">,</span>
                        <span class="n">context</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dialect</span><span class="o">.</span><span class="n">_has_events</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dialect</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">do_execute</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">fn</span><span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="n">statement</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
                            <span class="n">evt_handled</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="k">break</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">evt_handled</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dialect</span><span class="o">.</span><span class="n">do_execute</span><span class="p">(</span>
                        <span class="n">cursor</span><span class="p">,</span>
                        <span class="n">statement</span><span class="p">,</span>
                        <span class="n">parameters</span><span class="p">,</span>
                        <span class="n">context</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">BaseException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle_dbapi_exception</span><span class="p">(</span>
                <span class="n">e</span><span class="p">,</span>
                <span class="n">statement</span><span class="p">,</span>
                <span class="n">parameters</span><span class="p">,</span>
                <span class="n">cursor</span><span class="p">,</span>
                <span class="n">context</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_events</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">_has_events</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">after_cursor_execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cursor</span><span class="p">,</span>
                                               <span class="n">statement</span><span class="p">,</span>
                                               <span class="n">parameters</span><span class="p">,</span>
                                               <span class="n">context</span><span class="p">,</span>
                                               <span class="n">context</span><span class="o">.</span><span class="n">executemany</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">compiled</span><span class="p">:</span>
            <span class="n">context</span><span class="o">.</span><span class="n">post_exec</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">is_crud</span> <span class="ow">or</span> <span class="n">context</span><span class="o">.</span><span class="n">is_text</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">_setup_crud_result_proxy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">get_result_proxy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">_metadata</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">_soft_close</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">should_autocommit</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_root</span><span class="o">.</span><span class="n">__transaction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_root</span><span class="o">.</span><span class="n">_commit_impl</span><span class="p">(</span><span class="n">autocommit</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># for &quot;connectionless&quot; execution, we have to close this</span>
        <span class="c1"># Connection after the statement is complete.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">should_close_with_result</span><span class="p">:</span>
            <span class="c1"># ResultProxy already exhausted rows / has no rows.</span>
            <span class="c1"># close us now</span>
            <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">_soft_closed</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># ResultProxy will close this Connection when no more</span>
                <span class="c1"># rows to fetch.</span>
                <span class="n">result</span><span class="o">.</span><span class="n">_autoclose_connection</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_cursor_execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cursor</span><span class="p">,</span> <span class="n">statement</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Execute a statement + params on the given cursor.</span>

<span class="sd">        Adds appropriate logging and exception handling.</span>

<span class="sd">        This method is used by DefaultDialect for special-case</span>
<span class="sd">        executions, such as for sequences and column defaults.</span>
<span class="sd">        The path of statement execution in the majority of cases</span>
<span class="sd">        terminates at _execute_context().</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_events</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">_has_events</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">before_cursor_execute</span><span class="p">:</span>
                <span class="n">statement</span><span class="p">,</span> <span class="n">parameters</span> <span class="o">=</span> \
                    <span class="n">fn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cursor</span><span class="p">,</span> <span class="n">statement</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span>
                       <span class="n">context</span><span class="p">,</span>
                       <span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_echo</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">statement</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">dialect</span><span class="o">.</span><span class="n">_has_events</span> \
                    <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">dialect</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">do_execute</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">fn</span><span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="n">statement</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dialect</span><span class="o">.</span><span class="n">do_execute</span><span class="p">(</span>
                    <span class="n">cursor</span><span class="p">,</span>
                    <span class="n">statement</span><span class="p">,</span>
                    <span class="n">parameters</span><span class="p">,</span>
                    <span class="n">context</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">BaseException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle_dbapi_exception</span><span class="p">(</span>
                <span class="n">e</span><span class="p">,</span>
                <span class="n">statement</span><span class="p">,</span>
                <span class="n">parameters</span><span class="p">,</span>
                <span class="n">cursor</span><span class="p">,</span>
                <span class="n">context</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_events</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">_has_events</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">after_cursor_execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cursor</span><span class="p">,</span>
                                               <span class="n">statement</span><span class="p">,</span>
                                               <span class="n">parameters</span><span class="p">,</span>
                                               <span class="n">context</span><span class="p">,</span>
                                               <span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_safe_close_cursor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cursor</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Close the given cursor, catching exceptions</span>
<span class="sd">        and turning into log warnings.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">cursor</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="c1"># log the error through the connection pool&#39;s logger.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">pool</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;Error closing cursor&quot;</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">_reentrant_error</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">_is_disconnect</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_handle_dbapi_exception</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                <span class="n">e</span><span class="p">,</span>
                                <span class="n">statement</span><span class="p">,</span>
                                <span class="n">parameters</span><span class="p">,</span>
                                <span class="n">cursor</span><span class="p">,</span>
                                <span class="n">context</span><span class="p">):</span>
        <span class="n">exc_info</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">context</span> <span class="ow">and</span> <span class="n">context</span><span class="o">.</span><span class="n">exception</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">context</span><span class="o">.</span><span class="n">exception</span> <span class="o">=</span> <span class="n">e</span>

        <span class="n">is_exit_exception</span> <span class="o">=</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_disconnect</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_disconnect</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dialect</span><span class="o">.</span><span class="n">dbapi</span><span class="o">.</span><span class="n">Error</span><span class="p">)</span> <span class="ow">and</span>
                <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dialect</span><span class="o">.</span><span class="n">is_disconnect</span><span class="p">(</span>
                    <span class="n">e</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__connection</span> <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">invalidated</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">cursor</span><span class="p">)</span>
            <span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="n">is_exit_exception</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">context</span><span class="p">:</span>
                <span class="n">context</span><span class="o">.</span><span class="n">is_disconnect</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_disconnect</span>

        <span class="n">invalidate_pool_on_disconnect</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">is_exit_exception</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reentrant_error</span><span class="p">:</span>
            <span class="n">util</span><span class="o">.</span><span class="n">raise_from_cause</span><span class="p">(</span>
                <span class="n">exc</span><span class="o">.</span><span class="n">DBAPIError</span><span class="o">.</span><span class="n">instance</span><span class="p">(</span><span class="n">statement</span><span class="p">,</span>
                                        <span class="n">parameters</span><span class="p">,</span>
                                        <span class="n">e</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">dialect</span><span class="o">.</span><span class="n">dbapi</span><span class="o">.</span><span class="n">Error</span><span class="p">,</span>
                                        <span class="n">dialect</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dialect</span><span class="p">),</span>
                <span class="n">exc_info</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reentrant_error</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># non-DBAPI error - if we already got a context,</span>
            <span class="c1"># or there&#39;s no string statement, don&#39;t wrap it</span>
            <span class="n">should_wrap</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dialect</span><span class="o">.</span><span class="n">dbapi</span><span class="o">.</span><span class="n">Error</span><span class="p">)</span> <span class="ow">or</span> \
                <span class="p">(</span><span class="n">statement</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                 <span class="ow">and</span> <span class="n">context</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_exit_exception</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">should_wrap</span><span class="p">:</span>
                <span class="n">sqlalchemy_exception</span> <span class="o">=</span> <span class="n">exc</span><span class="o">.</span><span class="n">DBAPIError</span><span class="o">.</span><span class="n">instance</span><span class="p">(</span>
                    <span class="n">statement</span><span class="p">,</span>
                    <span class="n">parameters</span><span class="p">,</span>
                    <span class="n">e</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dialect</span><span class="o">.</span><span class="n">dbapi</span><span class="o">.</span><span class="n">Error</span><span class="p">,</span>
                    <span class="n">connection_invalidated</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_disconnect</span><span class="p">,</span>
                    <span class="n">dialect</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dialect</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sqlalchemy_exception</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="n">newraise</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_has_events</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">_has_events</span><span class="p">)</span> <span class="ow">and</span> \
                <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_execution_options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="s1">&#39;skip_user_error_events&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="c1"># legacy dbapi_error event</span>
                <span class="k">if</span> <span class="n">should_wrap</span> <span class="ow">and</span> <span class="n">context</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">dbapi_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                              <span class="n">cursor</span><span class="p">,</span>
                                              <span class="n">statement</span><span class="p">,</span>
                                              <span class="n">parameters</span><span class="p">,</span>
                                              <span class="n">context</span><span class="p">,</span>
                                              <span class="n">e</span><span class="p">)</span>

                <span class="c1"># new handle_error event</span>
                <span class="n">ctx</span> <span class="o">=</span> <span class="n">ExceptionContextImpl</span><span class="p">(</span>
                    <span class="n">e</span><span class="p">,</span> <span class="n">sqlalchemy_exception</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="p">,</span>
                    <span class="bp">self</span><span class="p">,</span> <span class="n">cursor</span><span class="p">,</span> <span class="n">statement</span><span class="p">,</span>
                    <span class="n">parameters</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_disconnect</span><span class="p">,</span>
                    <span class="n">invalidate_pool_on_disconnect</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">handle_error</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="c1"># handler returns an exception;</span>
                        <span class="c1"># call next handler in a chain</span>
                        <span class="n">per_fn</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">per_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">ctx</span><span class="o">.</span><span class="n">chained_exception</span> <span class="o">=</span> <span class="n">newraise</span> <span class="o">=</span> <span class="n">per_fn</span>
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">_raised</span><span class="p">:</span>
                        <span class="c1"># handler raises an exception - stop processing</span>
                        <span class="n">newraise</span> <span class="o">=</span> <span class="n">_raised</span>
                        <span class="k">break</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_disconnect</span> <span class="o">!=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">is_disconnect</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_is_disconnect</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">is_disconnect</span>
                    <span class="k">if</span> <span class="n">sqlalchemy_exception</span><span class="p">:</span>
                        <span class="n">sqlalchemy_exception</span><span class="o">.</span><span class="n">connection_invalidated</span> <span class="o">=</span> \
                            <span class="n">ctx</span><span class="o">.</span><span class="n">is_disconnect</span>

                <span class="c1"># set up potentially user-defined value for</span>
                <span class="c1"># invalidate pool.</span>
                <span class="n">invalidate_pool_on_disconnect</span> <span class="o">=</span> \
                    <span class="n">ctx</span><span class="o">.</span><span class="n">invalidate_pool_on_disconnect</span>

            <span class="k">if</span> <span class="n">should_wrap</span> <span class="ow">and</span> <span class="n">context</span><span class="p">:</span>
                <span class="n">context</span><span class="o">.</span><span class="n">handle_dbapi_exception</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_disconnect</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cursor</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_safe_close_cursor</span><span class="p">(</span><span class="n">cursor</span><span class="p">)</span>
                <span class="k">with</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_reraise</span><span class="p">(</span><span class="n">warn_only</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_autorollback</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">newraise</span><span class="p">:</span>
                <span class="n">util</span><span class="o">.</span><span class="n">raise_from_cause</span><span class="p">(</span><span class="n">newraise</span><span class="p">,</span> <span class="n">exc_info</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">should_wrap</span><span class="p">:</span>
                <span class="n">util</span><span class="o">.</span><span class="n">raise_from_cause</span><span class="p">(</span>
                    <span class="n">sqlalchemy_exception</span><span class="p">,</span>
                    <span class="n">exc_info</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">util</span><span class="o">.</span><span class="n">reraise</span><span class="p">(</span><span class="o">*</span><span class="n">exc_info</span><span class="p">)</span>

        <span class="k">finally</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reentrant_error</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_disconnect</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_disconnect</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">invalidated</span><span class="p">:</span>
                    <span class="n">dbapi_conn_wrapper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__connection</span>
                    <span class="k">if</span> <span class="n">invalidate_pool_on_disconnect</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">pool</span><span class="o">.</span><span class="n">_invalidate</span><span class="p">(</span><span class="n">dbapi_conn_wrapper</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">should_close_with_result</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_handle_dbapi_exception_noconnection</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">dialect</span><span class="p">,</span> <span class="n">engine</span><span class="p">):</span>
        <span class="n">exc_info</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()</span>

        <span class="n">is_disconnect</span> <span class="o">=</span> <span class="n">dialect</span><span class="o">.</span><span class="n">is_disconnect</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="n">should_wrap</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">dialect</span><span class="o">.</span><span class="n">dbapi</span><span class="o">.</span><span class="n">Error</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">should_wrap</span><span class="p">:</span>
            <span class="n">sqlalchemy_exception</span> <span class="o">=</span> <span class="n">exc</span><span class="o">.</span><span class="n">DBAPIError</span><span class="o">.</span><span class="n">instance</span><span class="p">(</span>
                <span class="kc">None</span><span class="p">,</span>
                <span class="kc">None</span><span class="p">,</span>
                <span class="n">e</span><span class="p">,</span>
                <span class="n">dialect</span><span class="o">.</span><span class="n">dbapi</span><span class="o">.</span><span class="n">Error</span><span class="p">,</span>
                <span class="n">connection_invalidated</span><span class="o">=</span><span class="n">is_disconnect</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sqlalchemy_exception</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">newraise</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">engine</span><span class="o">.</span><span class="n">_has_events</span><span class="p">:</span>
            <span class="n">ctx</span> <span class="o">=</span> <span class="n">ExceptionContextImpl</span><span class="p">(</span>
                <span class="n">e</span><span class="p">,</span> <span class="n">sqlalchemy_exception</span><span class="p">,</span> <span class="n">engine</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">is_disconnect</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">engine</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">handle_error</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># handler returns an exception;</span>
                    <span class="c1"># call next handler in a chain</span>
                    <span class="n">per_fn</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">per_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">ctx</span><span class="o">.</span><span class="n">chained_exception</span> <span class="o">=</span> <span class="n">newraise</span> <span class="o">=</span> <span class="n">per_fn</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">_raised</span><span class="p">:</span>
                    <span class="c1"># handler raises an exception - stop processing</span>
                    <span class="n">newraise</span> <span class="o">=</span> <span class="n">_raised</span>
                    <span class="k">break</span>

            <span class="k">if</span> <span class="n">sqlalchemy_exception</span> <span class="ow">and</span> \
                    <span class="n">is_disconnect</span> <span class="o">!=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">is_disconnect</span><span class="p">:</span>
                <span class="n">sqlalchemy_exception</span><span class="o">.</span><span class="n">connection_invalidated</span> <span class="o">=</span> \
                    <span class="n">is_disconnect</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">is_disconnect</span>

        <span class="k">if</span> <span class="n">newraise</span><span class="p">:</span>
            <span class="n">util</span><span class="o">.</span><span class="n">raise_from_cause</span><span class="p">(</span><span class="n">newraise</span><span class="p">,</span> <span class="n">exc_info</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">should_wrap</span><span class="p">:</span>
            <span class="n">util</span><span class="o">.</span><span class="n">raise_from_cause</span><span class="p">(</span>
                <span class="n">sqlalchemy_exception</span><span class="p">,</span>
                <span class="n">exc_info</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">util</span><span class="o">.</span><span class="n">reraise</span><span class="p">(</span><span class="o">*</span><span class="n">exc_info</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">transaction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callable_</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Execute the given function within a transaction boundary.</span>

<span class="sd">        The function is passed this :class:`.Connection`</span>
<span class="sd">        as the first argument, followed by the given \*args and \**kwargs,</span>
<span class="sd">        e.g.::</span>

<span class="sd">            def do_something(conn, x, y):</span>
<span class="sd">                conn.execute(&quot;some statement&quot;, {&#39;x&#39;:x, &#39;y&#39;:y})</span>

<span class="sd">            conn.transaction(do_something, 5, 10)</span>

<span class="sd">        The operations inside the function are all invoked within the</span>
<span class="sd">        context of a single :class:`.Transaction`.</span>
<span class="sd">        Upon success, the transaction is committed.  If an</span>
<span class="sd">        exception is raised, the transaction is rolled back</span>
<span class="sd">        before propagating the exception.</span>

<span class="sd">        .. note::</span>

<span class="sd">           The :meth:`.transaction` method is superseded by</span>
<span class="sd">           the usage of the Python ``with:`` statement, which can</span>
<span class="sd">           be used with :meth:`.Connection.begin`::</span>

<span class="sd">               with conn.begin():</span>
<span class="sd">                   conn.execute(&quot;some statement&quot;, {&#39;x&#39;:5, &#39;y&#39;:10})</span>

<span class="sd">           As well as with :meth:`.Engine.begin`::</span>

<span class="sd">               with engine.begin() as conn:</span>
<span class="sd">                   conn.execute(&quot;some statement&quot;, {&#39;x&#39;:5, &#39;y&#39;:10})</span>

<span class="sd">        See also:</span>

<span class="sd">            :meth:`.Engine.begin` - engine-level transactional</span>
<span class="sd">            context</span>

<span class="sd">            :meth:`.Engine.transaction` - engine-level version of</span>
<span class="sd">            :meth:`.Connection.transaction`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">begin</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_callable</span><span class="p">(</span><span class="n">callable_</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">trans</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">ret</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_reraise</span><span class="p">():</span>
                <span class="n">trans</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">run_callable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callable_</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Given a callable object or function, execute it, passing</span>
<span class="sd">        a :class:`.Connection` as the first argument.</span>

<span class="sd">        The given \*args and \**kwargs are passed subsequent</span>
<span class="sd">        to the :class:`.Connection` argument.</span>

<span class="sd">        This function, along with :meth:`.Engine.run_callable`,</span>
<span class="sd">        allows a function to be run with a :class:`.Connection`</span>
<span class="sd">        or :class:`.Engine` object without the need to know</span>
<span class="sd">        which one is being dealt with.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">callable_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_run_visitor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">visitorcallable</span><span class="p">,</span> <span class="n">element</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">visitorcallable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dialect</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">traverse_single</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ExceptionContextImpl</span><span class="p">(</span><span class="n">ExceptionContext</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Implement the :class:`.ExceptionContext` interface.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exception</span><span class="p">,</span> <span class="n">sqlalchemy_exception</span><span class="p">,</span>
                 <span class="n">engine</span><span class="p">,</span> <span class="n">connection</span><span class="p">,</span> <span class="n">cursor</span><span class="p">,</span> <span class="n">statement</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span>
                 <span class="n">context</span><span class="p">,</span> <span class="n">is_disconnect</span><span class="p">,</span> <span class="n">invalidate_pool_on_disconnect</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">engine</span> <span class="o">=</span> <span class="n">engine</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connection</span> <span class="o">=</span> <span class="n">connection</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sqlalchemy_exception</span> <span class="o">=</span> <span class="n">sqlalchemy_exception</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">original_exception</span> <span class="o">=</span> <span class="n">exception</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">execution_context</span> <span class="o">=</span> <span class="n">context</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">statement</span> <span class="o">=</span> <span class="n">statement</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="o">=</span> <span class="n">parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_disconnect</span> <span class="o">=</span> <span class="n">is_disconnect</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate_pool_on_disconnect</span> <span class="o">=</span> <span class="n">invalidate_pool_on_disconnect</span>


<span class="k">class</span> <span class="nc">Transaction</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent a database transaction in progress.</span>

<span class="sd">    The :class:`.Transaction` object is procured by</span>
<span class="sd">    calling the :meth:`~.Connection.begin` method of</span>
<span class="sd">    :class:`.Connection`::</span>

<span class="sd">        from sqlalchemy import create_engine</span>
<span class="sd">        engine = create_engine(&quot;postgresql://scott:tiger@localhost/test&quot;)</span>
<span class="sd">        connection = engine.connect()</span>
<span class="sd">        trans = connection.begin()</span>
<span class="sd">        connection.execute(&quot;insert into x (a, b) values (1, 2)&quot;)</span>
<span class="sd">        trans.commit()</span>

<span class="sd">    The object provides :meth:`.rollback` and :meth:`.commit`</span>
<span class="sd">    methods in order to control transaction boundaries.  It</span>
<span class="sd">    also implements a context manager interface so that</span>
<span class="sd">    the Python ``with`` statement can be used with the</span>
<span class="sd">    :meth:`.Connection.begin` method::</span>

<span class="sd">        with connection.begin():</span>
<span class="sd">            connection.execute(&quot;insert into x (a, b) values (1, 2)&quot;)</span>

<span class="sd">    The Transaction object is **not** threadsafe.</span>

<span class="sd">    See also:  :meth:`.Connection.begin`, :meth:`.Connection.begin_twophase`,</span>
<span class="sd">    :meth:`.Connection.begin_nested`.</span>

<span class="sd">    .. index::</span>
<span class="sd">      single: thread safety; Transaction</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connection</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connection</span> <span class="o">=</span> <span class="n">connection</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_actual_parent</span> <span class="o">=</span> <span class="n">parent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_active</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_parent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_actual_parent</span> <span class="ow">or</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Close this :class:`.Transaction`.</span>

<span class="sd">        If this transaction is the base transaction in a begin/commit</span>
<span class="sd">        nesting, the transaction will rollback().  Otherwise, the</span>
<span class="sd">        method returns.</span>

<span class="sd">        This is used to cancel a Transaction without affecting the scope of</span>
<span class="sd">        an enclosing transaction.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">is_active</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">rollback</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Roll back this :class:`.Transaction`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">is_active</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_do_rollback</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_active</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_do_rollback</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">commit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Commit this :class:`.Transaction`.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">is_active</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span><span class="s2">&quot;This transaction is inactive&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_do_commit</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_active</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_do_commit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_active</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_reraise</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">RootTransaction</span><span class="p">(</span><span class="n">Transaction</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connection</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">RootTransaction</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">connection</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">_begin_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_do_rollback</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_active</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">_rollback_impl</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_do_commit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_active</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">_commit_impl</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">NestedTransaction</span><span class="p">(</span><span class="n">Transaction</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent a &#39;nested&#39;, or SAVEPOINT transaction.</span>

<span class="sd">    A new :class:`.NestedTransaction` object may be procured</span>
<span class="sd">    using the :meth:`.Connection.begin_nested` method.</span>

<span class="sd">    The interface is the same as that of :class:`.Transaction`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connection</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">NestedTransaction</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">connection</span><span class="p">,</span> <span class="n">parent</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_savepoint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">_savepoint_impl</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_do_rollback</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_active</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">_rollback_to_savepoint_impl</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_savepoint</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_do_commit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_active</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">_release_savepoint_impl</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_savepoint</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">TwoPhaseTransaction</span><span class="p">(</span><span class="n">Transaction</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent a two-phase transaction.</span>

<span class="sd">    A new :class:`.TwoPhaseTransaction` object may be procured</span>
<span class="sd">    using the :meth:`.Connection.begin_twophase` method.</span>

<span class="sd">    The interface is the same as that of :class:`.Transaction`</span>
<span class="sd">    with the addition of the :meth:`prepare` method.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connection</span><span class="p">,</span> <span class="n">xid</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">TwoPhaseTransaction</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">connection</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_prepared</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xid</span> <span class="o">=</span> <span class="n">xid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">_begin_twophase_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">prepare</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Prepare this :class:`.TwoPhaseTransaction`.</span>

<span class="sd">        After a PREPARE, the transaction can be committed.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">is_active</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span><span class="s2">&quot;This transaction is inactive&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">_prepare_twophase_impl</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xid</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_prepared</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_do_rollback</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">_rollback_twophase_impl</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_prepared</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_do_commit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">_commit_twophase_impl</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_prepared</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Engine</span><span class="p">(</span><span class="n">Connectable</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">Identified</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Connects a :class:`~sqlalchemy.pool.Pool` and</span>
<span class="sd">    :class:`~sqlalchemy.engine.interfaces.Dialect` together to provide a</span>
<span class="sd">    source of database connectivity and behavior.</span>

<span class="sd">    An :class:`.Engine` object is instantiated publicly using the</span>
<span class="sd">    :func:`~sqlalchemy.create_engine` function.</span>

<span class="sd">    See also:</span>

<span class="sd">    :doc:`/core/engines`</span>

<span class="sd">    :ref:`connections_toplevel`</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_execution_options</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">immutabledict</span><span class="p">()</span>
    <span class="n">_has_events</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">_connection_cls</span> <span class="o">=</span> <span class="n">Connection</span>

    <span class="n">schema_for_object</span> <span class="o">=</span> <span class="n">schema</span><span class="o">.</span><span class="n">_schema_getter</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;Return the &quot;.schema&quot; attribute for an object.</span>

<span class="sd">    Used for :class:`.Table`, :class:`.Sequence` and similar objects,</span>
<span class="sd">    and takes into account</span>
<span class="sd">    the :paramref:`.Connection.execution_options.schema_translate_map`</span>
<span class="sd">    parameter.</span>

<span class="sd">      .. versionadded:: 1.1</span>

<span class="sd">      .. seealso::</span>

<span class="sd">          :ref:`schema_translating`</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pool</span><span class="p">,</span> <span class="n">dialect</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span>
                 <span class="n">logging_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">echo</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">proxy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">execution_options</span><span class="o">=</span><span class="kc">None</span>
                 <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pool</span> <span class="o">=</span> <span class="n">pool</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">url</span> <span class="o">=</span> <span class="n">url</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dialect</span> <span class="o">=</span> <span class="n">dialect</span>
        <span class="k">if</span> <span class="n">logging_name</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logging_name</span> <span class="o">=</span> <span class="n">logging_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">echo</span> <span class="o">=</span> <span class="n">echo</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">engine</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">log</span><span class="o">.</span><span class="n">instance_logger</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">echoflag</span><span class="o">=</span><span class="n">echo</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">proxy</span><span class="p">:</span>
            <span class="n">interfaces</span><span class="o">.</span><span class="n">ConnectionProxy</span><span class="o">.</span><span class="n">_adapt_listener</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proxy</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">execution_options</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_execution_options</span><span class="p">(</span><span class="o">**</span><span class="n">execution_options</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">update_execution_options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">opt</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Update the default execution_options dictionary</span>
<span class="sd">        of this :class:`.Engine`.</span>

<span class="sd">        The given keys/values in \**opt are added to the</span>
<span class="sd">        default execution options that will be used for</span>
<span class="sd">        all connections.  The initial contents of this dictionary</span>
<span class="sd">        can be sent via the ``execution_options`` parameter</span>
<span class="sd">        to :func:`.create_engine`.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.Connection.execution_options`</span>

<span class="sd">            :meth:`.Engine.execution_options`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_execution_options</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_execution_options</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">opt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">set_engine_execution_options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">opt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dialect</span><span class="o">.</span><span class="n">set_engine_execution_options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">opt</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">execution_options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">opt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new :class:`.Engine` that will provide</span>
<span class="sd">        :class:`.Connection` objects with the given execution options.</span>

<span class="sd">        The returned :class:`.Engine` remains related to the original</span>
<span class="sd">        :class:`.Engine` in that it shares the same connection pool and</span>
<span class="sd">        other state:</span>

<span class="sd">        * The :class:`.Pool` used by the new :class:`.Engine` is the</span>
<span class="sd">          same instance.  The :meth:`.Engine.dispose` method will replace</span>
<span class="sd">          the connection pool instance for the parent engine as well</span>
<span class="sd">          as this one.</span>
<span class="sd">        * Event listeners are &quot;cascaded&quot; - meaning, the new :class:`.Engine`</span>
<span class="sd">          inherits the events of the parent, and new events can be associated</span>
<span class="sd">          with the new :class:`.Engine` individually.</span>
<span class="sd">        * The logging configuration and logging_name is copied from the parent</span>
<span class="sd">          :class:`.Engine`.</span>

<span class="sd">        The intent of the :meth:`.Engine.execution_options` method is</span>
<span class="sd">        to implement &quot;sharding&quot; schemes where multiple :class:`.Engine`</span>
<span class="sd">        objects refer to the same connection pool, but are differentiated</span>
<span class="sd">        by options that would be consumed by a custom event::</span>

<span class="sd">            primary_engine = create_engine(&quot;mysql://&quot;)</span>
<span class="sd">            shard1 = primary_engine.execution_options(shard_id=&quot;shard1&quot;)</span>
<span class="sd">            shard2 = primary_engine.execution_options(shard_id=&quot;shard2&quot;)</span>

<span class="sd">        Above, the ``shard1`` engine serves as a factory for</span>
<span class="sd">        :class:`.Connection` objects that will contain the execution option</span>
<span class="sd">        ``shard_id=shard1``, and ``shard2`` will produce :class:`.Connection`</span>
<span class="sd">        objects that contain the execution option ``shard_id=shard2``.</span>

<span class="sd">        An event handler can consume the above execution option to perform</span>
<span class="sd">        a schema switch or other operation, given a connection.  Below</span>
<span class="sd">        we emit a MySQL ``use`` statement to switch databases, at the same</span>
<span class="sd">        time keeping track of which database we&#39;ve established using the</span>
<span class="sd">        :attr:`.Connection.info` dictionary, which gives us a persistent</span>
<span class="sd">        storage space that follows the DBAPI connection::</span>

<span class="sd">            from sqlalchemy import event</span>
<span class="sd">            from sqlalchemy.engine import Engine</span>

<span class="sd">            shards = {&quot;default&quot;: &quot;base&quot;, shard_1: &quot;db1&quot;, &quot;shard_2&quot;: &quot;db2&quot;}</span>

<span class="sd">            @event.listens_for(Engine, &quot;before_cursor_execute&quot;)</span>
<span class="sd">            def _switch_shard(conn, cursor, stmt,</span>
<span class="sd">                    params, context, executemany):</span>
<span class="sd">                shard_id = conn._execution_options.get(&#39;shard_id&#39;, &quot;default&quot;)</span>
<span class="sd">                current_shard = conn.info.get(&quot;current_shard&quot;, None)</span>

<span class="sd">                if current_shard != shard_id:</span>
<span class="sd">                    cursor.execute(&quot;use %s&quot; % shards[shard_id])</span>
<span class="sd">                    conn.info[&quot;current_shard&quot;] = shard_id</span>

<span class="sd">        .. versionadded:: 0.8</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.Connection.execution_options` - update execution options</span>
<span class="sd">            on a :class:`.Connection` object.</span>

<span class="sd">            :meth:`.Engine.update_execution_options` - update the execution</span>
<span class="sd">            options for a given :class:`.Engine` in place.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">OptionEngine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">opt</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String name of the :class:`~sqlalchemy.engine.interfaces.Dialect`</span>
<span class="sd">        in use by this :class:`Engine`.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dialect</span><span class="o">.</span><span class="n">name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">driver</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Driver name of the :class:`~sqlalchemy.engine.interfaces.Dialect`</span>
<span class="sd">        in use by this :class:`Engine`.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dialect</span><span class="o">.</span><span class="n">driver</span>

    <span class="n">echo</span> <span class="o">=</span> <span class="n">log</span><span class="o">.</span><span class="n">echo_property</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;Engine(</span><span class="si">%r</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">url</span>

    <span class="k">def</span> <span class="nf">dispose</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Dispose of the connection pool used by this :class:`.Engine`.</span>

<span class="sd">        This has the effect of fully closing all **currently checked in**</span>
<span class="sd">        database connections.  Connections that are still checked out</span>
<span class="sd">        will **not** be closed, however they will no longer be associated</span>
<span class="sd">        with this :class:`.Engine`, so when they are closed individually,</span>
<span class="sd">        eventually the :class:`.Pool` which they are associated with will</span>
<span class="sd">        be garbage collected and they will be closed out fully, if</span>
<span class="sd">        not already closed on checkin.</span>

<span class="sd">        A new connection pool is created immediately after the old one has</span>
<span class="sd">        been disposed.   This new pool, like all SQLAlchemy connection pools,</span>
<span class="sd">        does not make any actual connections to the database until one is</span>
<span class="sd">        first requested, so as long as the :class:`.Engine` isn&#39;t used again,</span>
<span class="sd">        no new connections will be made.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`engine_disposal`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pool</span><span class="o">.</span><span class="n">dispose</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pool</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pool</span><span class="o">.</span><span class="n">recreate</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">engine_disposed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_execute_default</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">default</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">contextual_connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">conn</span><span class="o">.</span><span class="n">_execute_default</span><span class="p">(</span><span class="n">default</span><span class="p">,</span> <span class="p">(),</span> <span class="p">{})</span>

    <span class="nd">@contextlib</span><span class="o">.</span><span class="n">contextmanager</span>
    <span class="k">def</span> <span class="nf">_optional_conn_ctx_manager</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connection</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">connection</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">contextual_connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">conn</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">connection</span>

    <span class="k">def</span> <span class="nf">_run_visitor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">visitorcallable</span><span class="p">,</span> <span class="n">element</span><span class="p">,</span>
                     <span class="n">connection</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_optional_conn_ctx_manager</span><span class="p">(</span><span class="n">connection</span><span class="p">)</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
            <span class="n">conn</span><span class="o">.</span><span class="n">_run_visitor</span><span class="p">(</span><span class="n">visitorcallable</span><span class="p">,</span> <span class="n">element</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">class</span> <span class="nc">_trans_ctx</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conn</span><span class="p">,</span> <span class="n">transaction</span><span class="p">,</span> <span class="n">close_with_result</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">conn</span> <span class="o">=</span> <span class="n">conn</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span> <span class="o">=</span> <span class="n">transaction</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">close_with_result</span> <span class="o">=</span> <span class="n">close_with_result</span>

        <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">conn</span>

        <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">close_with_result</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">begin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">close_with_result</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a context manager delivering a :class:`.Connection`</span>
<span class="sd">        with a :class:`.Transaction` established.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            with engine.begin() as conn:</span>
<span class="sd">                conn.execute(&quot;insert into table (x, y, z) values (1, 2, 3)&quot;)</span>
<span class="sd">                conn.execute(&quot;my_special_procedure(5)&quot;)</span>

<span class="sd">        Upon successful operation, the :class:`.Transaction`</span>
<span class="sd">        is committed.  If an error is raised, the :class:`.Transaction`</span>
<span class="sd">        is rolled back.</span>

<span class="sd">        The ``close_with_result`` flag is normally ``False``, and indicates</span>
<span class="sd">        that the :class:`.Connection` will be closed when the operation</span>
<span class="sd">        is complete.   When set to ``True``, it indicates the</span>
<span class="sd">        :class:`.Connection` is in &quot;single use&quot; mode, where the</span>
<span class="sd">        :class:`.ResultProxy` returned by the first call to</span>
<span class="sd">        :meth:`.Connection.execute` will close the :class:`.Connection` when</span>
<span class="sd">        that :class:`.ResultProxy` has exhausted all result rows.</span>

<span class="sd">        .. versionadded:: 0.7.6</span>

<span class="sd">        See also:</span>

<span class="sd">        :meth:`.Engine.connect` - procure a :class:`.Connection` from</span>
<span class="sd">        an :class:`.Engine`.</span>

<span class="sd">        :meth:`.Connection.begin` - start a :class:`.Transaction`</span>
<span class="sd">        for a particular :class:`.Connection`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">conn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">contextual_connect</span><span class="p">(</span><span class="n">close_with_result</span><span class="o">=</span><span class="n">close_with_result</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">trans</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">begin</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_reraise</span><span class="p">():</span>
                <span class="n">conn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">Engine</span><span class="o">.</span><span class="n">_trans_ctx</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">close_with_result</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">transaction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callable_</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Execute the given function within a transaction boundary.</span>

<span class="sd">        The function is passed a :class:`.Connection` newly procured</span>
<span class="sd">        from :meth:`.Engine.contextual_connect` as the first argument,</span>
<span class="sd">        followed by the given \*args and \**kwargs.</span>

<span class="sd">        e.g.::</span>

<span class="sd">            def do_something(conn, x, y):</span>
<span class="sd">                conn.execute(&quot;some statement&quot;, {&#39;x&#39;:x, &#39;y&#39;:y})</span>

<span class="sd">            engine.transaction(do_something, 5, 10)</span>

<span class="sd">        The operations inside the function are all invoked within the</span>
<span class="sd">        context of a single :class:`.Transaction`.</span>
<span class="sd">        Upon success, the transaction is committed.  If an</span>
<span class="sd">        exception is raised, the transaction is rolled back</span>
<span class="sd">        before propagating the exception.</span>

<span class="sd">        .. note::</span>

<span class="sd">           The :meth:`.transaction` method is superseded by</span>
<span class="sd">           the usage of the Python ``with:`` statement, which can</span>
<span class="sd">           be used with :meth:`.Engine.begin`::</span>

<span class="sd">               with engine.begin() as conn:</span>
<span class="sd">                   conn.execute(&quot;some statement&quot;, {&#39;x&#39;:5, &#39;y&#39;:10})</span>

<span class="sd">        See also:</span>

<span class="sd">            :meth:`.Engine.begin` - engine-level transactional</span>
<span class="sd">            context</span>

<span class="sd">            :meth:`.Connection.transaction` - connection-level version of</span>
<span class="sd">            :meth:`.Engine.transaction`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">contextual_connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">conn</span><span class="o">.</span><span class="n">transaction</span><span class="p">(</span><span class="n">callable_</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">run_callable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callable_</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Given a callable object or function, execute it, passing</span>
<span class="sd">        a :class:`.Connection` as the first argument.</span>

<span class="sd">        The given \*args and \**kwargs are passed subsequent</span>
<span class="sd">        to the :class:`.Connection` argument.</span>

<span class="sd">        This function, along with :meth:`.Connection.run_callable`,</span>
<span class="sd">        allows a function to be run with a :class:`.Connection`</span>
<span class="sd">        or :class:`.Engine` object without the need to know</span>
<span class="sd">        which one is being dealt with.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">contextual_connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">conn</span><span class="o">.</span><span class="n">run_callable</span><span class="p">(</span><span class="n">callable_</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">statement</span><span class="p">,</span> <span class="o">*</span><span class="n">multiparams</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Executes the given construct and returns a :class:`.ResultProxy`.</span>

<span class="sd">        The arguments are the same as those used by</span>
<span class="sd">        :meth:`.Connection.execute`.</span>

<span class="sd">        Here, a :class:`.Connection` is acquired using the</span>
<span class="sd">        :meth:`~.Engine.contextual_connect` method, and the statement executed</span>
<span class="sd">        with that connection. The returned :class:`.ResultProxy` is flagged</span>
<span class="sd">        such that when the :class:`.ResultProxy` is exhausted and its</span>
<span class="sd">        underlying cursor is closed, the :class:`.Connection` created here</span>
<span class="sd">        will also be closed, which allows its associated DBAPI connection</span>
<span class="sd">        resource to be returned to the connection pool.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">connection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">contextual_connect</span><span class="p">(</span><span class="n">close_with_result</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">statement</span><span class="p">,</span> <span class="o">*</span><span class="n">multiparams</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">statement</span><span class="p">,</span> <span class="o">*</span><span class="n">multiparams</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">statement</span><span class="p">,</span> <span class="o">*</span><span class="n">multiparams</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span><span class="o">.</span><span class="n">scalar</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_execute_clauseelement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elem</span><span class="p">,</span> <span class="n">multiparams</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">connection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">contextual_connect</span><span class="p">(</span><span class="n">close_with_result</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">connection</span><span class="o">.</span><span class="n">_execute_clauseelement</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">multiparams</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_execute_compiled</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">compiled</span><span class="p">,</span> <span class="n">multiparams</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="n">connection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">contextual_connect</span><span class="p">(</span><span class="n">close_with_result</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">connection</span><span class="o">.</span><span class="n">_execute_compiled</span><span class="p">(</span><span class="n">compiled</span><span class="p">,</span> <span class="n">multiparams</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new :class:`.Connection` object.</span>

<span class="sd">        The :class:`.Connection` object is a facade that uses a DBAPI</span>
<span class="sd">        connection internally in order to communicate with the database.  This</span>
<span class="sd">        connection is procured from the connection-holding :class:`.Pool`</span>
<span class="sd">        referenced by this :class:`.Engine`. When the</span>
<span class="sd">        :meth:`~.Connection.close` method of the :class:`.Connection` object</span>
<span class="sd">        is called, the underlying DBAPI connection is then returned to the</span>
<span class="sd">        connection pool, where it may be used again in a subsequent call to</span>
<span class="sd">        :meth:`~.Engine.connect`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection_cls</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">contextual_connect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">close_with_result</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a :class:`.Connection` object which may be part of some</span>
<span class="sd">        ongoing context.</span>

<span class="sd">        By default, this method does the same thing as :meth:`.Engine.connect`.</span>
<span class="sd">        Subclasses of :class:`.Engine` may override this method</span>
<span class="sd">        to provide contextual behavior.</span>

<span class="sd">        :param close_with_result: When True, the first :class:`.ResultProxy`</span>
<span class="sd">          created by the :class:`.Connection` will call the</span>
<span class="sd">          :meth:`.Connection.close` method of that connection as soon as any</span>
<span class="sd">          pending result rows are exhausted. This is used to supply the</span>
<span class="sd">          &quot;connectionless execution&quot; behavior provided by the</span>
<span class="sd">          :meth:`.Engine.execute` method.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection_cls</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_pool_connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pool</span><span class="o">.</span><span class="n">connect</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="n">close_with_result</span><span class="o">=</span><span class="n">close_with_result</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">table_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">connection</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of all table names available in the database.</span>

<span class="sd">        :param schema: Optional, retrieve names from a non-default schema.</span>

<span class="sd">        :param connection: Optional, use a specified connection. Default is</span>
<span class="sd">          the ``contextual_connect`` for this ``Engine``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_optional_conn_ctx_manager</span><span class="p">(</span><span class="n">connection</span><span class="p">)</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">schema</span><span class="p">:</span>
                <span class="n">schema</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dialect</span><span class="o">.</span><span class="n">default_schema_name</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dialect</span><span class="o">.</span><span class="n">get_table_names</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">schema</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">has_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table_name</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if the given backend has a table of the given name.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`metadata_reflection_inspector` - detailed schema inspection</span>
<span class="sd">            using the :class:`.Inspector` interface.</span>

<span class="sd">            :class:`.quoted_name` - used to pass quoting information along</span>
<span class="sd">            with a schema identifier.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dialect</span><span class="o">.</span><span class="n">has_table</span><span class="p">,</span> <span class="n">table_name</span><span class="p">,</span> <span class="n">schema</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_wrap_pool_connect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">connection</span><span class="p">):</span>
        <span class="n">dialect</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dialect</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fn</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">dialect</span><span class="o">.</span><span class="n">dbapi</span><span class="o">.</span><span class="n">Error</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">connection</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">Connection</span><span class="o">.</span><span class="n">_handle_dbapi_exception_noconnection</span><span class="p">(</span>
                    <span class="n">e</span><span class="p">,</span> <span class="n">dialect</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">util</span><span class="o">.</span><span class="n">reraise</span><span class="p">(</span><span class="o">*</span><span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">raw_connection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_connection</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a &quot;raw&quot; DBAPI connection from the connection pool.</span>

<span class="sd">        The returned object is a proxied version of the DBAPI</span>
<span class="sd">        connection object used by the underlying driver in use.</span>
<span class="sd">        The object will have all the same behavior as the real DBAPI</span>
<span class="sd">        connection, except that its ``close()`` method will result in the</span>
<span class="sd">        connection being returned to the pool, rather than being closed</span>
<span class="sd">        for real.</span>

<span class="sd">        This method provides direct DBAPI connection access for</span>
<span class="sd">        special situations when the API provided by :class:`.Connection`</span>
<span class="sd">        is not needed.   When a :class:`.Connection` object is already</span>
<span class="sd">        present, the DBAPI connection is available using</span>
<span class="sd">        the :attr:`.Connection.connection` accessor.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`dbapi_connections`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_pool_connect</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pool</span><span class="o">.</span><span class="n">unique_connection</span><span class="p">,</span> <span class="n">_connection</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">OptionEngine</span><span class="p">(</span><span class="n">Engine</span><span class="p">):</span>
    <span class="n">_sa_propagate_class_events</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proxied</span><span class="p">,</span> <span class="n">execution_options</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_proxied</span> <span class="o">=</span> <span class="n">proxied</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">url</span> <span class="o">=</span> <span class="n">proxied</span><span class="o">.</span><span class="n">url</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dialect</span> <span class="o">=</span> <span class="n">proxied</span><span class="o">.</span><span class="n">dialect</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logging_name</span> <span class="o">=</span> <span class="n">proxied</span><span class="o">.</span><span class="n">logging_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">echo</span> <span class="o">=</span> <span class="n">proxied</span><span class="o">.</span><span class="n">echo</span>
        <span class="n">log</span><span class="o">.</span><span class="n">instance_logger</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">echoflag</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">echo</span><span class="p">)</span>

        <span class="c1"># note: this will propagate events that are assigned to the parent</span>
        <span class="c1"># engine after this OptionEngine is created.   Since we share</span>
        <span class="c1"># the events of the parent we also disallow class-level events</span>
        <span class="c1"># to apply to the OptionEngine class directly.</span>
        <span class="c1">#</span>
        <span class="c1"># the other way this can work would be to transfer existing</span>
        <span class="c1"># events only, using:</span>
        <span class="c1"># self.dispatch._update(proxied.dispatch)</span>
        <span class="c1">#</span>
        <span class="c1"># that might be more appropriate however it would be a behavioral</span>
        <span class="c1"># change for logic that assigns events to the parent engine and</span>
        <span class="c1"># would like it to take effect for the already-created sub-engine.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">_join</span><span class="p">(</span><span class="n">proxied</span><span class="o">.</span><span class="n">dispatch</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_execution_options</span> <span class="o">=</span> <span class="n">proxied</span><span class="o">.</span><span class="n">_execution_options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_execution_options</span><span class="p">(</span><span class="o">**</span><span class="n">execution_options</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_pool</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_proxied</span><span class="o">.</span><span class="n">pool</span>

    <span class="k">def</span> <span class="nf">_set_pool</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pool</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_proxied</span><span class="o">.</span><span class="n">pool</span> <span class="o">=</span> <span class="n">pool</span>

    <span class="n">pool</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_pool</span><span class="p">,</span> <span class="n">_set_pool</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_has_events</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_proxied</span><span class="o">.</span><span class="n">_has_events</span> <span class="ow">or</span> \
            <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;_has_events&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_has_events</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;_has_events&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="n">_has_events</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_has_events</span><span class="p">,</span> <span class="n">_set_has_events</span><span class="p">)</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Author.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    

    
  </body>
</html>